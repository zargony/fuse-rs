//! Low-level filesystem operation replies.
//!
//! A reply is returned by the implementation of filesystem operations as the result of executing
//! the requested operation. The reply is then sent back to the kernel driver.

use fuse_abi::*;
use std::io::IoSlice;
use std::ops::Deref;
use std::os::raw::c_int;
use std::time::{Duration, SystemTime, SystemTimeError, UNIX_EPOCH};
use std::{mem, slice};

use super::attr::{FileAttr, FileType};


/// Returns a tuple of seconds and nanoseconds from a given SystemTime.
fn time_from_system_time(system_time: &SystemTime) -> Result<(u64, u32), SystemTimeError> {
    let duration = system_time.duration_since(UNIX_EPOCH)?;
    Ok((duration.as_secs(), duration.subsec_nanos()))
}

/// Create a mode integer for a given FileType and permission.
fn mode_from_type_and_perm(file_type: FileType, perm: u16) -> u32 {
    u32::from(match file_type {
        FileType::NamedPipe => libc::S_IFIFO,
        FileType::CharDevice => libc::S_IFCHR,
        FileType::BlockDevice => libc::S_IFBLK,
        FileType::Directory => libc::S_IFDIR,
        FileType::RegularFile => libc::S_IFREG,
        FileType::Symlink => libc::S_IFLNK,
        FileType::Socket => libc::S_IFSOCK,
    }) | u32::from(perm)
}

/// Create a fuse_attr from a given FileAttr.
fn fuse_attr_from_attr(attr: &FileAttr) -> fuse_attr {
    // FIXME: unwrap may panic, use unwrap_or((0, 0)) or return a result instead?
    let (atime_secs, atime_nanos) = time_from_system_time(&attr.atime).unwrap();
    let (mtime_secs, mtime_nanos) = time_from_system_time(&attr.mtime).unwrap();
    let (ctime_secs, ctime_nanos) = time_from_system_time(&attr.ctime).unwrap();
    #[cfg(target_os = "macos")]
    let (crtime_secs, crtime_nanos) = time_from_system_time(&attr.crtime).unwrap();

    fuse_attr {
        ino: attr.ino,
        size: attr.size,
        blocks: attr.blocks,
        atime: atime_secs,
        mtime: mtime_secs,
        ctime: ctime_secs,
        #[cfg(target_os = "macos")]
        crtime: crtime_secs,
        atimensec: atime_nanos,
        mtimensec: mtime_nanos,
        ctimensec: ctime_nanos,
        #[cfg(target_os = "macos")]
        crtimensec: crtime_nanos,
        mode: mode_from_type_and_perm(attr.ftype, attr.perm),
        nlink: attr.nlink,
        uid: attr.uid,
        gid: attr.gid,
        rdev: attr.rdev,
        #[cfg(target_os = "macos")]
        flags: attr.flags,
    }
}

/// Returns an IoSlice (memory dump) of an arbitrary type.
fn as_io_slice<T>(data: &T) -> IoSlice<'_> {
    match mem::size_of::<T>() {
        0 => IoSlice::new(&[]),
        len => {
            let ptr = data as *const T as *const u8;
            let bytes = unsafe { slice::from_raw_parts(ptr, len) };
            IoSlice::new(bytes)
        }
    }
}


/// Trait to get an IoSlice (memory dump) of a type.
pub trait AsIoSlice {
    /// Returns an IoSlice (memory dump) of the type.
    fn as_io_slice(&self) -> IoSlice<'_>;
}


/// Low-level reply to report back the result of a filesystem operation to the kernel driver.
#[derive(Debug)]
pub(crate) struct Reply<'a, T> {
    header: fuse_out_header,
    payload: Option<&'a T>,
}

impl<'a, T: AsIoSlice> Reply<'a, T> {
    /// Create a new reply for the given request using the given payload.
    // FIXME: this should consume a `Request` instead of passing the unique id
    pub fn new(unique: u64, res: Result<&'a T, c_int>) -> Self {
        let len = res.map(|payload| payload.as_io_slice().len()).unwrap_or(0);
        let header = fuse_out_header {
            len: (mem::size_of::<fuse_out_header>() + len) as u32,
            error: -res.err().unwrap_or(0) as i32,
            unique,
        };
        Self {
            header,
            payload: res.ok(),
        }
    }

    /// Convert the reply to a vector of byte slices that can be sent to the kernel driver.
    pub fn to_io_slices(&self) -> Vec<IoSlice<'_>> {
        let mut bufs = vec![as_io_slice(&self.header)];
        if let Some(payload) = self.payload {
            bufs.push(payload.as_io_slice());
        }
        bufs
    }
}


/// Reply with attributes.
#[derive(Debug)]
pub struct Attr {
    inner: fuse_attr_out,
}

impl AsIoSlice for Attr {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Attr {
    /// Create a new reply with attributes.
    pub fn new(ttl: &Duration, attr: &FileAttr) -> Self {
        Self {
            inner: fuse_attr_out {
                attr_valid: ttl.as_secs(),
                attr_valid_nsec: ttl.subsec_nanos(),
                dummy: 0,
                attr: fuse_attr_from_attr(attr),
            },
        }
    }
}


/// Reply with block index.
#[derive(Debug)]
pub struct Bmap {
    inner: fuse_bmap_out,
}

impl AsIoSlice for Bmap {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Bmap {
    /// Create a new reply with block index.
    pub fn new(block: u64) -> Self {
        Self {
            inner: fuse_bmap_out { block },
        }
    }
}


/// Reply with a directory entry and open parameters.
// TODO: Use `(Entry, Open)` instead
#[derive(Debug)]
pub struct Create {
    inner: (fuse_entry_out, fuse_open_out),
}

impl AsIoSlice for Create {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Create {
    /// Create a new reply with a directory entry and open parameters.
    // TODO: use typed open_flags
    pub fn new(ttl: &Duration, attr: &FileAttr, generation: u64, fh: u64, open_flags: u32) -> Self {
        Self {
            inner: (
                fuse_entry_out {
                    nodeid: attr.ino,
                    generation,
                    entry_valid: ttl.as_secs(),
                    attr_valid: ttl.as_secs(),
                    entry_valid_nsec: ttl.subsec_nanos(),
                    attr_valid_nsec: ttl.subsec_nanos(),
                    attr: fuse_attr_from_attr(attr),
                },
                fuse_open_out {
                    fh,
                    open_flags,
                    padding: 0,
                },
            ),
        }
    }
}


/// Reply with data (borrowed or owned)
// TODO: add data variant based on IoSlice(s)
pub enum Data<'a> {
    Borrowed(&'a [u8]),
    Owned(Vec<u8>),
}

impl AsIoSlice for Data<'_> {
    fn as_io_slice(&self) -> IoSlice<'_> {
        IoSlice::new(&**self)
    }
}

impl Deref for Data<'_> {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        match *self {
            Data::Borrowed(data) => data,
            Data::Owned(ref data) => data,
        }
    }
}

impl<'a> From<&'a [u8]> for Data<'a> {
    fn from(data: &'a [u8]) -> Self {
        Data::Borrowed(data)
    }
}

impl From<Vec<u8>> for Data<'_> {
    fn from(data: Vec<u8>) -> Self {
        Data::Owned(data)
    }
}


/// Reply with a directory entry.
#[derive(Debug)]
pub struct Entry {
    inner: fuse_entry_out,
}

impl AsIoSlice for Entry {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Entry {
    /// Create a new reply with a directory entry.
    pub fn new(ttl: &Duration, attr: &FileAttr, generation: u64) -> Self {
        Self {
            inner: fuse_entry_out {
                nodeid: attr.ino,
                generation,
                entry_valid: ttl.as_secs(),
                attr_valid: ttl.as_secs(),
                entry_valid_nsec: ttl.subsec_nanos(),
                attr_valid_nsec: ttl.subsec_nanos(),
                attr: fuse_attr_from_attr(attr),
            },
        }
    }
}


/// Reply with init information.
#[derive(Debug)]
pub struct Init {
    inner: fuse_init_out,
}

impl AsIoSlice for Init {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Init {
    /// Create a new reply with init information.
    // TODO: use typed init_flags
    pub fn new(
        major: u32,
        minor: u32,
        max_readahead: u32,
        init_flags: u32,
        max_write: u32,
    ) -> Self {
        Self {
            inner: fuse_init_out {
                major,
                minor,
                max_readahead,
                flags: init_flags,
                unused: 0,
                max_write,
            },
        }
    }
}


/// Reply with file lock information.
#[derive(Debug)]
pub struct Lock {
    inner: fuse_lk_out,
}

impl AsIoSlice for Lock {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Lock {
    /// Create a new reply with file lock information.
    pub fn new(start: u64, end: u64, typ: u32, pid: u32) -> Self {
        Self {
            inner: fuse_lk_out {
                lk: fuse_file_lock {
                    start,
                    end,
                    typ,
                    pid,
                },
            },
        }
    }
}


/// Reply with open parameters.
#[derive(Debug)]
pub struct Open {
    inner: fuse_open_out,
}

impl AsIoSlice for Open {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Open {
    /// Create a new reply with open parameters.
    // TODO: use typed open_flags
    pub fn new(fh: u64, open_flags: u32) -> Self {
        Self {
            inner: fuse_open_out {
                fh,
                open_flags,
                padding: 0,
            },
        }
    }
}


/// Reply with filesystem statistics.
#[derive(Debug)]
pub struct StatFs {
    inner: fuse_statfs_out,
}

impl AsIoSlice for StatFs {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl StatFs {
    /// Create a new reply with filesystem statistics.
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        blocks: u64,
        bfree: u64,
        bavail: u64,
        files: u64,
        ffree: u64,
        bsize: u32,
        namelen: u32,
        frsize: u32,
    ) -> Self {
        Self {
            inner: fuse_statfs_out {
                st: fuse_kstatfs {
                    blocks,
                    bfree,
                    bavail,
                    files,
                    ffree,
                    bsize,
                    namelen,
                    frsize,
                    padding: 0,
                    spare: [0; 6],
                },
            },
        }
    }
}


/// Reply with number of bytes written.
#[derive(Debug)]
pub struct Write {
    inner: fuse_write_out,
}

impl AsIoSlice for Write {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl Write {
    /// Create a new reply with number of bytes written.
    pub fn new(size: u32) -> Self {
        Self {
            inner: fuse_write_out { size, padding: 0 },
        }
    }
}


/// Reply with size of extended attribute.
#[derive(Debug)]
pub struct XAttrSize {
    inner: fuse_getxattr_out,
}

impl AsIoSlice for XAttrSize {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

impl XAttrSize {
    /// Create a new reply with size of extended attribute.
    pub fn new(size: u32) -> Self {
        Self {
            inner: fuse_getxattr_out { size, padding: 0 },
        }
    }
}


/// macOS only: Reply with extended times.
#[derive(Debug)]
#[cfg(target_os = "macos")]
pub struct XTimes {
    inner: fuse_getxtimes_out,
}

#[cfg(target_os = "macos")]
impl AsIoSlice for XTimes {
    fn as_io_slice(&self) -> IoSlice<'_> {
        as_io_slice(&self.inner)
    }
}

#[cfg(target_os = "macos")]
impl XTimes {
    /// Create a new reply with extended times.
    pub fn new(bkuptime: &SystemTime, crtime: &SystemTime) -> Self {
        // FIXME: unwrap may panic, use unwrap_or((0, 0)) or return a result instead?
        let (bkuptime_secs, bkuptime_nanos) = time_from_system_time(bkuptime).unwrap();
        let (crtime_secs, crtime_nanos) = time_from_system_time(crtime).unwrap();
        Self {
            inner: fuse_getxtimes_out {
                bkuptime: bkuptime_secs,
                crtime: crtime_secs,
                bkuptimensec: bkuptime_nanos,
                crtimensec: crtime_nanos,
            },
        }
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    fn concat_reply<T: AsIoSlice>(reply: &Reply<'_, T>) -> Vec<u8> {
        reply
            .to_io_slices()
            .iter()
            .fold(Vec::new(), |mut data, buf| {
                data.extend_from_slice(buf);
                data
            })
    }

    #[cfg(target_endian = "big")]
    const ERROR_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xbe, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
    ];

    #[cfg(target_endian = "little")]
    const ERROR_REPLY: &[u8] = &[
        0x10, 0x00, 0x00, 0x00, 0xbe, 0xff, 0xff, 0xff, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
    ];

    #[test]
    fn error() {
        let reply: Reply<'_, Attr> = Reply::new(0xdead_beef_baad_f00d, Err(66));
        assert_eq!(concat_reply(&reply), ERROR_REPLY);
    }

    #[cfg(target_endian = "big")]
    const ATTR_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, // attr_valid
        0x00, 0x00, 0x12, 0x34, 0x00, 0x00, 0x00, 0x00, // attr_valid_nsec, dummy
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, // ino
        0x00, 0x00, 0x00, 0x00, 0xdf, 0x1a, 0xad, 0xa5, // size
        0x00, 0x00, 0x00, 0x00, 0x10, 0xdf, 0x41, 0x0f, // blocks
        0x00, 0x00, 0x00, 0x00, 0x5b, 0xcd, 0xa7, 0x00, // atime
        0x00, 0x00, 0x00, 0x00, 0x54, 0x4e, 0xad, 0x28, // mtime
        0x00, 0x00, 0x00, 0x00, 0x54, 0x9b, 0x41, 0xef, // ctime
        0x11, 0x11, 0x55, 0x55, 0x11, 0x11, 0x33, 0x33, // atimensec, mtimensec
        0x11, 0x11, 0x44, 0x44, 0x00, 0x00, 0x81, 0xa4, // ctimensec, mode
        0x00, 0x00, 0x00, 0x01, 0xc0, 0x01, 0xd0, 0x0d, // nlink, uid
        0xc0, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x08, // gid, rdev
    ];

    #[cfg(all(target_endian = "little", target_os = "macos"))]
    const ATTR_REPLY: &[u8] = &[
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid
        0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid_nsec, dummy
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // ino
        0xa5, 0xad, 0x1a, 0xdf, 0x00, 0x00, 0x00, 0x00, // size
        0x0f, 0x41, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00, // blocks
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // atime
        0x28, 0xad, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, // mtime
        0xef, 0x41, 0x9b, 0x54, 0x00, 0x00, 0x00, 0x00, // ctime
        0xa7, 0x94, 0x4d, 0x52, 0x00, 0x00, 0x00, 0x00, // crtime
        0x55, 0x55, 0x11, 0x11, 0x33, 0x33, 0x11, 0x11, // atimensec, mtimensec
        0x44, 0x44, 0x11, 0x11, 0x22, 0x22, 0x11, 0x11, // ctimensec, crtimensec
        0xa4, 0x81, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mode, nlink
        0x0d, 0xd0, 0x01, 0xc0, 0xfe, 0xca, 0x01, 0xc0, // uid, gid
        0x08, 0x00, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // rdev, flags
    ];

    #[cfg(all(target_endian = "little", not(target_os = "macos")))]
    const ATTR_REPLY: &[u8] = &[
        0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid
        0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid_nsec, dummy
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // ino
        0xa5, 0xad, 0x1a, 0xdf, 0x00, 0x00, 0x00, 0x00, // size
        0x0f, 0x41, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00, // blocks
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // atime
        0x28, 0xad, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, // mtime
        0xef, 0x41, 0x9b, 0x54, 0x00, 0x00, 0x00, 0x00, // ctime
        0x55, 0x55, 0x11, 0x11, 0x33, 0x33, 0x11, 0x11, // atimensec, mtimensec
        0x44, 0x44, 0x11, 0x11, 0xa4, 0x81, 0x00, 0x00, // ctimensec, mode
        0x01, 0x00, 0x00, 0x00, 0x0d, 0xd0, 0x01, 0xc0, // nlink, uid
        0xfe, 0xca, 0x01, 0xc0, 0x08, 0x00, 0x00, 0x00, // gid, rdev
    ];

    #[test]
    fn attr() {
        let ttl = Duration::new(0x0123, 0x1234);
        let attr = FileAttr {
            ino: 0x1122_3344_5566_7788,
            size: 0xdf1a_ada5,
            blocks: 0x10df_410f,
            atime: UNIX_EPOCH + Duration::new(0x5bcd_a700, 0x1111_5555),
            mtime: UNIX_EPOCH + Duration::new(0x544e_ad28, 0x1111_3333),
            ctime: UNIX_EPOCH + Duration::new(0x549b_41ef, 0x1111_4444),
            #[cfg(target_os = "macos")]
            crtime: UNIX_EPOCH + Duration::new(0x524d_94a7, 0x1111_2222),
            ftype: FileType::RegularFile,
            perm: 0o644,
            nlink: 0x01,
            uid: 0xc001_d00d,
            gid: 0xc001_cafe,
            rdev: 0x08,
            #[cfg(target_os = "macos")]
            flags: 0x1234,
        };
        let payload = Attr::new(&ttl, &attr);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), ATTR_REPLY);
    }

    #[cfg(target_endian = "big")]
    const BMAP_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, // block
    ];

    #[cfg(target_endian = "little")]
    const BMAP_REPLY: &[u8] = &[
        0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // block
    ];

    #[test]
    fn bmap() {
        let payload = Bmap::new(0x1234);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), BMAP_REPLY);
    }

    #[cfg(target_endian = "big")]
    const CREATE_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, // nodeid
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // generation
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, // entry_valid
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, // attr_valid
        0x00, 0x00, 0x12, 0x34, 0x00, 0x00, 0x12, 0x34, // entry_valid_nsec, attr_valid_nsec
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, // ino
        0x00, 0x00, 0x00, 0x00, 0xdf, 0x1a, 0xad, 0xa5, // size
        0x00, 0x00, 0x00, 0x00, 0x10, 0xdf, 0x41, 0x0f, // blocks
        0x00, 0x00, 0x00, 0x00, 0x5b, 0xcd, 0xa7, 0x00, // atime
        0x00, 0x00, 0x00, 0x00, 0x54, 0x4e, 0xad, 0x28, // mtime
        0x00, 0x00, 0x00, 0x00, 0x54, 0x9b, 0x41, 0xef, // ctime
        0x11, 0x11, 0x55, 0x55, 0x11, 0x11, 0x33, 0x33, // atimensec, mtimensec
        0x11, 0x11, 0x44, 0x44, 0x00, 0x00, 0x81, 0xa4, // ctimensec, mode
        0x00, 0x00, 0x00, 0x01, 0xc0, 0x01, 0xd0, 0x0d, // nlink, uid
        0xc0, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x08, // gid, rdev
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, // fh
        0x00, 0x00, 0x23, 0x45, 0x00, 0x00, 0x00, 0x00, // open_flags, padding
    ];

    #[cfg(all(target_endian = "little", target_os = "macos"))]
    const CREATE_REPLY: &[u8] = &[
        0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // nodeid
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // generation
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // entry_valid
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid
        0x34, 0x12, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // entry_valid_nsec, attr_valid_nsec
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // ino
        0xa5, 0xad, 0x1a, 0xdf, 0x00, 0x00, 0x00, 0x00, // size
        0x0f, 0x41, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00, // blocks
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // atime
        0x28, 0xad, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, // mtime
        0xef, 0x41, 0x9b, 0x54, 0x00, 0x00, 0x00, 0x00, // ctime
        0xa7, 0x94, 0x4d, 0x52, 0x00, 0x00, 0x00, 0x00, // crtime
        0x55, 0x55, 0x11, 0x11, 0x33, 0x33, 0x11, 0x11, // atimensec, mtimensec
        0x44, 0x44, 0x11, 0x11, 0x22, 0x22, 0x11, 0x11, // ctimensec, crtimensec
        0xa4, 0x81, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mode, nlink
        0x0d, 0xd0, 0x01, 0xc0, 0xfe, 0xca, 0x01, 0xc0, // uid, gid
        0x08, 0x00, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // rdev, flags
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // fh
        0x45, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // open_flags, padding
    ];

    #[cfg(all(target_endian = "little", not(target_os = "macos")))]
    const CREATE_REPLY: &[u8] = &[
        0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // nodeid
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // generation
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // entry_valid
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid
        0x34, 0x12, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // entry_valid_nsec, attr_valid_nsec
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // ino
        0xa5, 0xad, 0x1a, 0xdf, 0x00, 0x00, 0x00, 0x00, // size
        0x0f, 0x41, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00, // blocks
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // atime
        0x28, 0xad, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, // mtime
        0xef, 0x41, 0x9b, 0x54, 0x00, 0x00, 0x00, 0x00, // ctime
        0x55, 0x55, 0x11, 0x11, 0x33, 0x33, 0x11, 0x11, // atimensec, mtimensec
        0x44, 0x44, 0x11, 0x11, 0xa4, 0x81, 0x00, 0x00, // ctimensec, mode
        0x01, 0x00, 0x00, 0x00, 0x0d, 0xd0, 0x01, 0xc0, // nlink, uid
        0xfe, 0xca, 0x01, 0xc0, 0x08, 0x00, 0x00, 0x00, // gid, rdev
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // fh
        0x45, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // open_flags, padding
    ];

    #[test]
    fn create() {
        let ttl = Duration::new(0x0123, 0x1234);
        let attr = FileAttr {
            ino: 0x1122_3344_5566_7788,
            size: 0xdf1a_ada5,
            blocks: 0x10df_410f,
            atime: UNIX_EPOCH + Duration::new(0x5bcd_a700, 0x1111_5555),
            mtime: UNIX_EPOCH + Duration::new(0x544e_ad28, 0x1111_3333),
            ctime: UNIX_EPOCH + Duration::new(0x549b_41ef, 0x1111_4444),
            #[cfg(target_os = "macos")]
            crtime: UNIX_EPOCH + Duration::new(0x524d_94a7, 0x1111_2222),
            ftype: FileType::RegularFile,
            perm: 0o644,
            nlink: 0x01,
            uid: 0xc001_d00d,
            gid: 0xc001_cafe,
            rdev: 0x08,
            #[cfg(target_os = "macos")]
            flags: 0x1234,
        };
        let payload = Create::new(&ttl, &attr, 0x01, 0x05, 0x2345);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), CREATE_REPLY);
    }

    #[cfg(target_endian = "big")]
    const DATA_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // data
    ];

    #[cfg(target_endian = "little")]
    const DATA_REPLY: &[u8] = &[
        0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // data
    ];

    #[test]
    fn data_borrowed() {
        let data: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
        let payload = Data::from(data);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), DATA_REPLY);
    }

    #[test]
    fn data_owned() {
        let data: Vec<u8> = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
        let payload = Data::from(data);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), DATA_REPLY);
    }

    #[cfg(target_endian = "big")]
    const ENTRY_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, // nodeid
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // generation
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, // entry_valid
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, // attr_valid
        0x00, 0x00, 0x12, 0x34, 0x00, 0x00, 0x12, 0x34, // entry_valid_nsec, attr_valid_nsec
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, // ino
        0x00, 0x00, 0x00, 0x00, 0xdf, 0x1a, 0xad, 0xa5, // size
        0x00, 0x00, 0x00, 0x00, 0x10, 0xdf, 0x41, 0x0f, // blocks
        0x00, 0x00, 0x00, 0x00, 0x5b, 0xcd, 0xa7, 0x00, // atime
        0x00, 0x00, 0x00, 0x00, 0x54, 0x4e, 0xad, 0x28, // mtime
        0x00, 0x00, 0x00, 0x00, 0x54, 0x9b, 0x41, 0xef, // ctime
        0x11, 0x11, 0x55, 0x55, 0x11, 0x11, 0x33, 0x33, // atimensec, mtimensec
        0x11, 0x11, 0x44, 0x44, 0x00, 0x00, 0x81, 0xa4, // ctimensec, mode
        0x00, 0x00, 0x00, 0x01, 0xc0, 0x01, 0xd0, 0x0d, // nlink, uid
        0xc0, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x08, // gid, rdev
    ];

    #[cfg(all(target_endian = "little", target_os = "macos"))]
    const ENTRY_REPLY: &[u8] = &[
        0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // nodeid
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // generation
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // entry_valid
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid
        0x34, 0x12, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // entry_valid_nsec, attr_valid_nsec
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // ino
        0xa5, 0xad, 0x1a, 0xdf, 0x00, 0x00, 0x00, 0x00, // size
        0x0f, 0x41, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00, // blocks
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // atime
        0x28, 0xad, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, // mtime
        0xef, 0x41, 0x9b, 0x54, 0x00, 0x00, 0x00, 0x00, // ctime
        0xa7, 0x94, 0x4d, 0x52, 0x00, 0x00, 0x00, 0x00, // crtime
        0x55, 0x55, 0x11, 0x11, 0x33, 0x33, 0x11, 0x11, // atimensec, mtimensec
        0x44, 0x44, 0x11, 0x11, 0x22, 0x22, 0x11, 0x11, // ctimensec, crtimensec
        0xa4, 0x81, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mode, nlink
        0x0d, 0xd0, 0x01, 0xc0, 0xfe, 0xca, 0x01, 0xc0, // uid, gid
        0x08, 0x00, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // rdev, flags
    ];

    #[cfg(all(target_endian = "little", not(target_os = "macos")))]
    const ENTRY_REPLY: &[u8] = &[
        0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // nodeid
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // generation
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // entry_valid
        0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // attr_valid
        0x34, 0x12, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00, // entry_valid_nsec, attr_valid_nsec
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, // ino
        0xa5, 0xad, 0x1a, 0xdf, 0x00, 0x00, 0x00, 0x00, // size
        0x0f, 0x41, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00, // blocks
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // atime
        0x28, 0xad, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, // mtime
        0xef, 0x41, 0x9b, 0x54, 0x00, 0x00, 0x00, 0x00, // ctime
        0x55, 0x55, 0x11, 0x11, 0x33, 0x33, 0x11, 0x11, // atimensec, mtimensec
        0x44, 0x44, 0x11, 0x11, 0xa4, 0x81, 0x00, 0x00, // ctimensec, mode
        0x01, 0x00, 0x00, 0x00, 0x0d, 0xd0, 0x01, 0xc0, // nlink, uid
        0xfe, 0xca, 0x01, 0xc0, 0x08, 0x00, 0x00, 0x00, // gid, rdev
    ];

    #[test]
    fn entry() {
        let ttl = Duration::new(0x0123, 0x1234);
        let attr = FileAttr {
            ino: 0x1122_3344_5566_7788,
            size: 0xdf1a_ada5,
            blocks: 0x10df_410f,
            atime: UNIX_EPOCH + Duration::new(0x5bcd_a700, 0x1111_5555),
            mtime: UNIX_EPOCH + Duration::new(0x544e_ad28, 0x1111_3333),
            ctime: UNIX_EPOCH + Duration::new(0x549b_41ef, 0x1111_4444),
            #[cfg(target_os = "macos")]
            crtime: UNIX_EPOCH + Duration::new(0x524d_94a7, 0x1111_2222),
            ftype: FileType::RegularFile,
            perm: 0o644,
            nlink: 0x01,
            uid: 0xc001_d00d,
            gid: 0xc001_cafe,
            rdev: 0x08,
            #[cfg(target_os = "macos")]
            flags: 0x1234,
        };
        let payload = Entry::new(&ttl, &attr, 0x01);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), ENTRY_REPLY);
    }

    #[cfg(target_endian = "big")]
    const INIT_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x22, 0x22, // major, minor
        0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x44, 0x44, // max_readahead, flags
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, // unused, max_write
    ];

    #[cfg(target_endian = "little")]
    const INIT_REPLY: &[u8] = &[
        0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x11, 0x11, 0x00, 0x00, 0x22, 0x22, 0x00, 0x00, // major, minor
        0x33, 0x33, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00, // max_readahead, flags
        0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, // unused, max_write
    ];

    #[test]
    fn init() {
        let payload = Init::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), INIT_REPLY);
    }

    #[cfg(target_endian = "big")]
    const LOCK_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, // start
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, // end
        0x00, 0x00, 0x55, 0x55, 0xc0, 0xde, 0xba, 0x5e, // typ, pid
    ];

    #[cfg(target_endian = "little")]
    const LOCK_REPLY: &[u8] = &[
        0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // start
        0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // end
        0x55, 0x55, 0x00, 0x00, 0x5e, 0xba, 0xde, 0xc0, // typ, pid
    ];

    #[test]
    fn lock() {
        let payload = Lock::new(0x1111, 0x2222, 0x5555, 0xc0de_ba5e);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), LOCK_REPLY);
    }

    #[cfg(target_endian = "big")]
    const OPEN_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, // fh
        0x00, 0x00, 0x23, 0x45, 0x00, 0x00, 0x00, 0x00, // open_flags, padding
    ];

    #[cfg(target_endian = "little")]
    const OPEN_REPLY: &[u8] = &[
        0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // fh
        0x45, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // open_flags, padding
    ];

    #[test]
    fn open() {
        let payload = Open::new(0x05, 0x2345);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), OPEN_REPLY);
    }

    #[cfg(target_endian = "big")]
    const STATFS_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, // blocks
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, // bfree
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, // bavail
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, // files
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, // ffree
        0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x77, 0x77, // bsize, namelen
        0x00, 0x00, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, // frsize, padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // spare
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // spare
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // spare
    ];

    #[cfg(target_endian = "little")]
    const STATFS_REPLY: &[u8] = &[
        0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // blocks
        0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bfree
        0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bavail
        0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // files
        0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ffree
        0x66, 0x66, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, // bsize, namelen
        0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // frsize, padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // spare
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // spare
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // spare
    ];

    #[test]
    fn statfs() {
        let payload = StatFs::new(
            0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888,
        );
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), STATFS_REPLY);
    }

    #[cfg(target_endian = "big")]
    const WRITE_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, // size, padding
    ];

    #[cfg(target_endian = "little")]
    const WRITE_REPLY: &[u8] = &[
        0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, // size, padding
    ];

    #[test]
    fn write() {
        let payload = Write::new(0x1234_5678);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), WRITE_REPLY);
    }

    #[cfg(target_endian = "big")]
    const XATTRSIZE_REPLY: &[u8] = &[
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, // len, error
        0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, // unique
        0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, // size, padding
    ];

    #[cfg(target_endian = "little")]
    const XATTRSIZE_REPLY: &[u8] = &[
        0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, // size, padding
    ];

    #[test]
    fn xattrsize() {
        let payload = XAttrSize::new(0x1234_5678);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), XATTRSIZE_REPLY);
    }

    #[cfg(target_os = "macos")]
    const XTIMES_REPLY: &[u8] = &[
        0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // len, error
        0x0d, 0xf0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde, // unique
        0x00, 0xa7, 0xcd, 0x5b, 0x00, 0x00, 0x00, 0x00, // bkuptime
        0xa7, 0x94, 0x4d, 0x52, 0x00, 0x00, 0x00, 0x00, // crtime
        0x55, 0x55, 0x11, 0x11, 0x22, 0x22, 0x11, 0x11, // bkuptime_nanos, crtime_nanos
    ];

    #[test]
    #[cfg(target_os = "macos")]
    fn xtimes() {
        let bkuptime = UNIX_EPOCH + Duration::new(0x5bcd_a700, 0x1111_5555);
        let crtime = UNIX_EPOCH + Duration::new(0x524d_94a7, 0x1111_2222);
        let payload = XTimes::new(&bkuptime, &crtime);
        let reply = Reply::new(0xdead_beef_baad_f00d, Ok(&payload));
        assert_eq!(concat_reply(&reply), XTIMES_REPLY);
    }
}
